{"version":3,"file":"main.bundle.js","mappings":"mBAAO,MCAP,o2B,YCEaA,SAASC,eAAe,gBAC/BC,UFHqB,MACvB,IAAIC,EAAS,wCAiBb,OAhBKC,UAAUC,MACXF,EAAS,kDAeNA,GEfKG,G,OAEiB,E,OAAA,E,EAAA,Y,MAC7BC,QAAQC,IAAI,UAEZ,MAAMC,EAAmCT,SAASC,eAAe,iBAC3DS,QAAgD,QAAb,EAAAN,UAAUC,WAAG,eAAEM,iBAClDC,QAA0BF,MAAAA,OAAO,EAAPA,EAASG,gBACnCC,EAAmCL,EAAOM,WAAW,UACrDC,EAAS,aAOf,IAAIC,EALJH,MAAAA,GAAAA,EAASI,UAAU,CACfN,OAAAA,EACAI,OAAAA,IAIJC,EAAWL,EAAOO,qBAAqB,CACvCC,OAAQ,CACJC,OAAQT,EAAOU,mBAAmB,CAC9BC,KAAMC,IAEVC,WAAY,WAEhBC,SAAU,CACNL,OAAQT,EAAOU,mBAAmB,CAC9BC,KAAMC,IAEVC,WAAY,UACZE,QAAS,CAAC,CAAEX,OAAAA,KAEhBY,UAAW,CACPC,SAAU,iBAEdC,OAAQlB,EAAOmB,qBAAqB,CAACC,iBAAiB,OAG1D,MAAMC,EAAiBrB,EAAOsB,uBACxBC,EAAcrB,MAAAA,OAAO,EAAPA,EAASsB,oBAAoBC,aAC3CC,EAAaL,EAAeM,gBAAgB,CAC9CC,iBAAkB,CAAC,CACfC,KAAKN,EACLO,WAAW,CAACC,EAAE,GAAKC,EAAE,GAAKC,EAAE,GAAKC,EAAE,GACnCC,OAAQ,QACRC,QAAQ,YAIhBV,EAAWW,YAAYhC,GACvBqB,EAAWY,KAAK,EAAE,EAAE,EAAE,GACtBZ,EAAWa,MAEXvC,EAAOwC,MAAMC,OAAO,CAACpB,EAAeqB,Y,YAlDH,K","sources":["webpack://webgpu_tutorial/./src/helper.ts","webpack://webgpu_tutorial/./src/shader.wgsl","webpack://webgpu_tutorial/./src/main.ts"],"sourcesContent":["export const CheckWebGPU = () => {\r\n    let result = 'Your current browser supports WebGPU!';\r\n    if (!navigator.gpu) {\r\n        result = `Your current browser does not support WebGPU!.`;\r\n    } \r\n\r\n    // const canvas = <HTMLCanvasElement>document.getElementById('canvas-webgpu');\r\n    // if(canvas){\r\n    //     const div = <HTMLDivElement>document.getElementsByClassName('item2')[0];\r\n    //     canvas.width  = div.offsetWidth;\r\n    //     canvas.height = div.offsetHeight;\r\n\r\n    //     function windowResize() {\r\n    //         canvas.width  = div.offsetWidth;\r\n    //         canvas.height = div.offsetHeight;\r\n    //     };\r\n    //     window.addEventListener('resize', windowResize);\r\n    // }\r\n    return result;\r\n}\r\n","export default \"// vertex shader\\r\\n\\r\\nstruct Output {\\r\\n    @builtin(position) Position : vec4<f32>,\\r\\n    @location(0) vColor : vec4<f32>\\r\\n};\\r\\n\\r\\n@stage(vertex)\\r\\nfn vs_main(@builtin(vertex_index) VertexIndex: u32) -> Output {\\r\\n    var pos = array<vec2<f32>, 3>(\\r\\n        vec2<f32>(0.0, 0.5),\\r\\n        vec2<f32>(-0.5, -0.5),\\r\\n        vec2<f32>(0.5, -0.5)\\r\\n    );\\r\\n\\r\\n    var color = array<vec3<f32>, 3>(\\r\\n        vec3<f32>(1.0, 0.0, 0.0),\\r\\n        vec3<f32>(0.0, 1.0, 0.0),\\r\\n        vec3<f32>(0.0, 0.0, 1.0)\\r\\n    );\\r\\n\\r\\n    var output: Output;\\r\\n    output.Position = vec4<f32>(pos[VertexIndex], 0.0, 1.0);\\r\\n    output.vColor = vec4<f32>(color[VertexIndex], 1.0);\\r\\n    return output;\\r\\n}\\r\\n\\r\\n// fragment shader\\r\\n\\r\\n@stage(fragment)\\r\\nfn fs_main(@location(0) vColor: vec4<f32>) -> @location(0) vec4<f32> {\\r\\n    return vColor;\\r\\n}\"","import { CheckWebGPU } from \"./helper\";\r\nimport shader from './shader.wgsl'\r\nconst head = document.getElementById(\"id-gpu-check\");\r\nhead!.innerHTML=CheckWebGPU();\r\n\r\nconst CreateTriangle = async() => {\r\n    console.log(\"called\")\r\n    \r\n    const canvas: HTMLCanvasElement | null = document.getElementById(\"canvas-webgpu\") as HTMLCanvasElement;\r\n    const adapter: GPUAdapter | null = await navigator.gpu?.requestAdapter();\r\n    const device: GPUDevice = await adapter?.requestDevice() as GPUDevice;\r\n    const context: GPUCanvasContext | null = canvas.getContext(\"webgpu\");\r\n    const format = 'bgra8unorm';\r\n\r\n    context?.configure({\r\n        device,\r\n        format\r\n    });\r\n\r\n    let pipeline: GPURenderPipeline;\r\n    pipeline = device.createRenderPipeline({\r\n    vertex: {\r\n        module: device.createShaderModule({\r\n            code: shader\r\n        }),\r\n        entryPoint: \"vs_main\"\r\n    },\r\n    fragment: {\r\n        module: device.createShaderModule({\r\n            code: shader\r\n        }),\r\n        entryPoint: \"fs_main\",\r\n        targets: [{ format }]\r\n    },\r\n    primitive: {\r\n        topology: \"triangle-list\"\r\n    },\r\n    layout: device.createPipelineLayout({bindGroupLayouts:[]}),\r\n});\r\n\r\nconst commandEncoder = device.createCommandEncoder();\r\nconst textureView = context?.getCurrentTexture().createView() as GPUTextureView;\r\nconst renderPass = commandEncoder.beginRenderPass({\r\n    colorAttachments: [{\r\n        view:textureView,\r\n        clearValue:{r:0.2, g:0.4, b:0.2, a:1.0},\r\n        loadOp: 'clear',\r\n        storeOp:'store'\r\n    }]\r\n});\r\n\r\nrenderPass.setPipeline(pipeline);\r\nrenderPass.draw(3,1,0,0);\r\nrenderPass.end();\r\n\r\ndevice.queue.submit([commandEncoder.finish()]);\r\n}\r\n\r\nCreateTriangle();\r\n"],"names":["document","getElementById","innerHTML","result","navigator","gpu","CheckWebGPU","console","log","canvas","adapter","requestAdapter","device","requestDevice","context","getContext","format","pipeline","configure","createRenderPipeline","vertex","module","createShaderModule","code","shader","entryPoint","fragment","targets","primitive","topology","layout","createPipelineLayout","bindGroupLayouts","commandEncoder","createCommandEncoder","textureView","getCurrentTexture","createView","renderPass","beginRenderPass","colorAttachments","view","clearValue","r","g","b","a","loadOp","storeOp","setPipeline","draw","end","queue","submit","finish"],"sourceRoot":""}