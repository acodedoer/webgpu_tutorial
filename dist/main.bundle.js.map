{"version":3,"file":"main.bundle.js","mappings":"mBAAO,MAAMA,EAAc,KACvB,IAAIC,EAAS,GAIb,OAHKC,UAAUC,MACXF,EAAS,kDAENA,GA4BEG,EAAkB,CAACC,EAAkBC,EAAoBC,EAAgCC,eAAeC,OAASD,eAAeE,YACxI,MAAMC,EAASN,EAAOO,aAAa,CAC/BC,KAAMP,EAAKQ,WACXC,MAAMR,EACNS,kBAAkB,IAKtB,OAFA,IAAIC,aAAaN,EAAOO,kBAAkBC,IAAIb,GAC9CK,EAAOS,QACAT,GC1CZ,8f,YCEaU,SAASC,eAAe,gBAC/BC,UAAUvB,I,OAEgB,E,OAAA,E,EAAA,YAC5B,MAAMG,Q,OFEwB,E,OAAA,E,OAAA,E,EAAA,Y,MAE9B,GADeH,IACLwB,SAAS,iDACf,KAAK,qBAGT,MAAMC,EAASJ,SAASC,eAAe,iBACjCI,QAA6B,QAAb,EAAAxB,UAAUC,WAAG,eAAEwB,iBAC/BtB,QAAeqB,MAAAA,OAAO,EAAPA,EAASE,gBACxBC,EAAUJ,EAAOK,WAAW,UAO5BC,GALmBC,OAAOC,iBAE5BR,EAAOS,YACPT,EAAOU,mBAEUjC,UAAUC,IAAIiC,4BAMnC,OAJAP,EAAQQ,UAAU,CACdhC,OAAAA,EAAO0B,OAAAA,IAGJ,CAAC1B,OAAAA,EAAQoB,OAAAA,EAAQM,OAAAA,EAAQF,QAAAA,I,2QEvB1BxB,EAAoBF,EAAIE,OAExBiC,EAAa,IAAIrB,aAAa,EAC/B,IAAM,GACP,IAAM,IACL,GAAK,IACL,GAAK,GACN,IAAM,GACN,GAAK,KAGHsB,EAAY,IAAItB,aAAa,CAC/B,EAAE,EAAE,EACJ,EAAE,EAAE,EACJ,EAAE,EAAE,EACJ,EAAE,EAAE,EACJ,EAAE,EAAE,EACJ,EAAE,EAAE,IAGFuB,EAAepC,EAAgBC,EAAOiC,GACtCG,EAAcrC,EAAgBC,EAAQkC,GAEtCG,EAAWrC,EAAOsC,qBAAqB,CACzCC,OAAQ,CACJC,OAAQxC,EAAOyC,mBAAmB,CAC9BC,KAAKC,IAETC,WAAY,UACZC,QAAQ,CACJ,CACIC,YAAY,EACZC,WAAW,CAAC,CACRC,eAAe,EACftB,OAAQ,YACRuB,OAAO,KAGf,CACIH,YAAY,GACZC,WAAW,CAAC,CACRC,eAAe,EACftB,OAAQ,YACRuB,OAAO,OAIvBC,SAAU,CACNV,OAAQxC,EAAOyC,mBAAmB,CAC9BC,KAAMC,IAEVC,WAAY,UACZO,QAAS,CACL,CACIzB,OAAQ5B,EAAI4B,UAIxB0B,UAAU,CACNC,SAAU,iBAEdC,OAAQtD,EAAOuD,qBAAqB,CAACC,iBAAiB,OAGpDC,EAAiBzD,EAAO0D,uBACxBC,EAAc7D,EAAI0B,QAAQoC,oBAAoBC,aAC9CC,EAAaL,EAAeM,gBAAgB,CAC9CC,iBAAkB,CAAC,CACfC,KAAKN,EACLO,WAAW,CAACC,EAAE,GAAKC,EAAE,GAAKC,EAAE,GAAKC,EAAE,GACnCC,OAAQ,QACRC,QAAQ,Y,YAIhBV,EAAWW,YAAYpC,GACvByB,EAAWY,gBAAgB,EAAGvC,GAC9B2B,EAAWY,gBAAgB,EAAGtC,GAC9B0B,EAAWa,KAAK,GAChBb,EAAWc,MAEX5E,EAAO6E,MAAMC,OAAO,CAACrB,EAAesB,Y,YAnFR,K","sources":["webpack://webgpu_tutorial/./src/helper.ts","webpack://webgpu_tutorial/./src/shader.wgsl","webpack://webgpu_tutorial/./src/main.ts"],"sourcesContent":["export const CheckWebGPU = () => {\r\n    let result = '';\r\n    if (!navigator.gpu) {\r\n        result = `Your current browser does not support WebGPU!.`;\r\n    } \r\n    return result;\r\n}\r\n\r\nexport const InitGPU = async () => {\r\n    const status = CheckWebGPU();\r\n    if(status.includes('Your current browser does not support WebGPU!')){\r\n        throw('No WebGPU Support!');\r\n    }\r\n\r\n    const canvas = document.getElementById(\"canvas-webgpu\") as HTMLCanvasElement;\r\n    const adapter = await navigator.gpu?.requestAdapter();\r\n    const device = await adapter?.requestDevice() as GPUDevice;\r\n    const context = canvas.getContext(\"webgpu\") as unknown as GPUCanvasContext;\r\n\r\n    const devicePixelRatio = window.devicePixelRatio || 1;\r\n    const size = [\r\n        canvas.clientWidth *devicePixelRatio,\r\n        canvas.clientHeight *devicePixelRatio\r\n    ];\r\n    const format = await navigator.gpu.getPreferredCanvasFormat();\r\n\r\n    context.configure({\r\n        device,format\r\n    })\r\n\r\n    return {device, canvas, format, context};\r\n}\r\n\r\nexport const CreateGPUBuffer = (device:GPUDevice, data: Float32Array, usageFlag:GPUBufferUsageFlags = GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST) => {\r\n     const buffer = device.createBuffer({\r\n         size: data.byteLength,\r\n         usage:usageFlag,\r\n         mappedAtCreation: true\r\n     });\r\n\r\n     new Float32Array(buffer.getMappedRange()).set(data);\r\n     buffer.unmap();\r\n     return buffer;\r\n}","export default \"// vertex shader\\r\\n\\r\\nstruct Output {\\r\\n    @builtin(position) Position : vec4<f32>,\\r\\n    @location(0) vColor : vec4<f32>\\r\\n};\\r\\n\\r\\n@stage(vertex)\\r\\nfn vs_main(@location(0) pos: vec4<f32>, @location(1) color: vec4<f32>) -> Output {\\r\\n    var output: Output;\\r\\n    output.Position = pos;\\r\\n    output.vColor = color;\\r\\n    return output;\\r\\n}\\r\\n\\r\\n// fragment shader\\r\\n\\r\\n@stage(fragment)\\r\\nfn fs_main(@location(0) vColor: vec4<f32>) -> @location(0) vec4<f32> {\\r\\n    return vColor;\\r\\n}\"","import { CheckWebGPU, InitGPU, CreateGPUBuffer } from \"./helper\";\r\nimport shader from './shader.wgsl'\r\nconst head = document.getElementById(\"id-gpu-check\");\r\nhead!.innerHTML=CheckWebGPU();\r\n\r\nconst CreateSquare = async() => {\r\n    const gpu = await InitGPU();\r\n    const device: GPUDevice = gpu.device;\r\n\r\n    const vertexData = new Float32Array([\r\n        -0.5, -0.5,\r\n        0.5, -0.5,\r\n        -0.5, 0.5,\r\n        -0.5, 0.5,\r\n        0.5, -0.5,\r\n        0.5, 0.5\r\n    ])\r\n\r\n    const colorData = new Float32Array([\r\n        1,0,0,\r\n        0,1,0,\r\n        1,1,0,\r\n        1,1,0,\r\n        0,1,0,\r\n        0,0,1\r\n    ])\r\n\r\n    const vertexBuffer = CreateGPUBuffer(device,vertexData);\r\n    const colorBuffer = CreateGPUBuffer(device, colorData);\r\n\r\n    const pipeline = device.createRenderPipeline({\r\n        vertex: {\r\n            module: device.createShaderModule({\r\n                code:shader\r\n            }),\r\n            entryPoint: \"vs_main\",\r\n            buffers:[ \r\n                {\r\n                    arrayStride:8,\r\n                    attributes:[{\r\n                        shaderLocation:0,\r\n                        format: \"float32x2\",\r\n                        offset:0\r\n                    }]\r\n                },\r\n                {\r\n                    arrayStride:12,\r\n                    attributes:[{\r\n                        shaderLocation:1,\r\n                        format: \"float32x2\",\r\n                        offset:0\r\n                    }]\r\n                }]\r\n        },\r\n        fragment: {\r\n            module: device.createShaderModule({\r\n                code: shader,\r\n            }),\r\n            entryPoint: \"fs_main\",\r\n            targets: [\r\n                {\r\n                    format: gpu.format as GPUTextureFormat\r\n                }\r\n            ]\r\n        },\r\n        primitive:{\r\n            topology: \"triangle-list\"\r\n        },\r\n        layout: device.createPipelineLayout({bindGroupLayouts:[]})\r\n    })\r\n\r\n    const commandEncoder = device.createCommandEncoder();\r\n    const textureView = gpu.context.getCurrentTexture().createView();\r\n    const renderPass = commandEncoder.beginRenderPass({\r\n        colorAttachments: [{\r\n            view:textureView,\r\n            clearValue:{r:0.2, g:0.4, b:0.2, a:1.0},\r\n            loadOp: 'clear',\r\n            storeOp:'store'\r\n        }]\r\n    })\r\n\r\n    renderPass.setPipeline(pipeline);\r\n    renderPass.setVertexBuffer(0, vertexBuffer);\r\n    renderPass.setVertexBuffer(1, colorBuffer),\r\n    renderPass.draw(6);\r\n    renderPass.end();\r\n\r\n    device.queue.submit([commandEncoder.finish()]);\r\n}\r\n\r\nCreateSquare();\r\n"],"names":["CheckWebGPU","result","navigator","gpu","CreateGPUBuffer","device","data","usageFlag","GPUBufferUsage","VERTEX","COPY_DST","buffer","createBuffer","size","byteLength","usage","mappedAtCreation","Float32Array","getMappedRange","set","unmap","document","getElementById","innerHTML","includes","canvas","adapter","requestAdapter","requestDevice","context","getContext","format","window","devicePixelRatio","clientWidth","clientHeight","getPreferredCanvasFormat","configure","vertexData","colorData","vertexBuffer","colorBuffer","pipeline","createRenderPipeline","vertex","module","createShaderModule","code","shader","entryPoint","buffers","arrayStride","attributes","shaderLocation","offset","fragment","targets","primitive","topology","layout","createPipelineLayout","bindGroupLayouts","commandEncoder","createCommandEncoder","textureView","getCurrentTexture","createView","renderPass","beginRenderPass","colorAttachments","view","clearValue","r","g","b","a","loadOp","storeOp","setPipeline","setVertexBuffer","draw","end","queue","submit","finish"],"sourceRoot":""}