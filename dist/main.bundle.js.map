{"version":3,"file":"main.bundle.js","mappings":"mBAAO,MAAMA,EAAc,KACvB,IAAIC,EAAS,GAIb,OAHKC,UAAUC,MACXF,EAAS,kDAENA,GCLX,42CCEaG,SAASC,eAAe,gBAC/BC,UAAUN,IAEhB,MAAMO,EAAkB,CAAOC,EAAgB,mBAAoB,O,OAAA,E,OAAA,E,EAAA,Y,MAC/D,MAAML,Q,OFEwB,E,OAAA,E,OAAA,E,EAAA,Y,MAE9B,GADeH,IACLS,SAAS,iDACf,KAAK,qBAGT,MAAMC,EAASN,SAASC,eAAe,iBACjCM,QAA6B,QAAb,EAAAT,UAAUC,WAAG,eAAES,iBAC/BC,QAAeF,MAAAA,OAAO,EAAPA,EAASG,gBACxBC,EAAUL,EAAOM,WAAW,UAO5BC,GALmBC,OAAOC,iBAE5BT,EAAOU,YACPV,EAAOW,mBAEUnB,UAAUC,IAAImB,4BAMnC,OAJAP,EAAQQ,UAAU,CACdV,OAAAA,EAAOI,OAAAA,IAGJ,CAACJ,OAAAA,EAAQH,OAAAA,EAAQO,OAAAA,EAAQF,QAAAA,I,2QEvB1BF,EAASV,EAAIU,OACbI,EAASd,EAAIc,O,YAEnB,IAAIO,EAKAC,EAJiB,mBAAlBjB,IACCgB,EAAc,UAIlBC,EAAWZ,EAAOa,qBAAqB,CACnCC,OAAQ,CACJC,OAAQf,EAAOgB,mBAAmB,CAC9BC,KAAM,IAEVC,WAAY,WAEhBC,SAAU,CACNJ,OAAQf,EAAOgB,mBAAmB,CAC9BC,KAAM,IAEVC,WAAY,UACZE,QAAS,CAAC,CAAEhB,OAAAA,KAEhBiB,UAAW,CACPC,SAAU3B,EACV4B,iBAAkBZ,GAEtBa,OAAQxB,EAAOyB,qBAAqB,CAACC,iBAAiB,OAE1D,MAAMC,EAAiB3B,EAAO4B,uBACxBC,EAAyB,QAAX,EAAAvC,EAAIY,eAAO,eAAE4B,oBAAoBC,aAC/CC,EAAaL,EAAeM,gBAAgB,CAC9CC,iBAAkB,CAAC,CACfC,KAAKN,EACLO,WAAW,CAACC,EAAE,GAAKC,EAAE,GAAKC,EAAE,GAAKC,EAAE,GACnCC,OAAQ,QACRC,QAAQ,YAIhBV,EAAWW,YAAY/B,GACvBoB,EAAWY,KAAK,GAChBZ,EAAWa,MACX7C,EAAO8C,MAAMC,OAAO,CAACpB,EAAeqB,Y,YA7C2B,K,+QAsInEtD,IACwBH,SAASC,eAAe,gBAC9ByD,iBAAiB,UAAWC,IAC1CxD,EAAgBwD,EAAEC,WAAWC,W","sources":["webpack://webgpu_tutorial/./src/helper.ts","webpack://webgpu_tutorial/./src/shader.wgsl","webpack://webgpu_tutorial/./src/main.ts"],"sourcesContent":["export const CheckWebGPU = () => {\r\n    let result = '';\r\n    if (!navigator.gpu) {\r\n        result = `Your current browser does not support WebGPU!.`;\r\n    } \r\n    return result;\r\n}\r\n\r\nexport const InitGPU = async () => {\r\n    const status = CheckWebGPU();\r\n    if(status.includes('Your current browser does not support WebGPU!')){\r\n        throw('No WebGPU Support!');\r\n    }\r\n\r\n    const canvas = document.getElementById(\"canvas-webgpu\") as HTMLCanvasElement;\r\n    const adapter = await navigator.gpu?.requestAdapter();\r\n    const device = await adapter?.requestDevice() as GPUDevice;\r\n    const context = canvas.getContext(\"webgpu\") as unknown as GPUCanvasContext;\r\n\r\n    const devicePixelRatio = window.devicePixelRatio || 1;\r\n    const size = [\r\n        canvas.clientWidth *devicePixelRatio,\r\n        canvas.clientHeight *devicePixelRatio\r\n    ];\r\n    const format = await navigator.gpu.getPreferredCanvasFormat();\r\n\r\n    context.configure({\r\n        device,format\r\n    })\r\n\r\n    return {device, canvas, format, context};\r\n}\r\n\r\nexport const CreateGPUBuffer = (device:GPUDevice, data: Float32Array, usageFlag:GPUBufferUsageFlags = GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST) => {\r\n     const buffer = device.createBuffer({\r\n         size: data.byteLength,\r\n         usage:usageFlag,\r\n         mappedAtCreation: true\r\n     });\r\n\r\n     new Float32Array(buffer.getMappedRange()).set(data);\r\n     buffer.unmap();\r\n     return buffer;\r\n}","export default \"// vertex shader\\r\\nstruct Output {\\r\\n    @builtin(position) Position : vec4<f32>,\\r\\n    @location(0) vColor : vec4<f32>\\r\\n};\\r\\n\\r\\n@stage(vertex)\\r\\nfn vs_main(@builtin(vertex_index) VertexIndex: u32) -> Output{\\r\\n    var pos : array<vec2<f32>, 9> = array<vec2<f32>, 9>(             \\r\\n        vec2<f32>(-0.63,  0.80),\\r\\n        vec2<f32>(-0.65,  0.20),\\r\\n        vec2<f32>(-0.20,  0.60),\\r\\n        vec2<f32>(-0.37, -0.07),\\r\\n        vec2<f32>( 0.05,  0.18),\\r\\n        vec2<f32>(-0.13, -0.40),\\r\\n        vec2<f32>( 0.30, -0.13),\\r\\n        vec2<f32>( 0.13, -0.64),\\r\\n        vec2<f32>( 0.70, -0.30)     \\r\\n    );\\r\\n\\r\\n    var color : array<vec3<f32>, 9> = array<vec3<f32>, 9>(             \\r\\n        vec3<f32>(1.0, 0.0, 0.0),\\r\\n        vec3<f32>(0.0, 1.0, 0.0),\\r\\n        vec3<f32>(0.0, 0.0, 1.0),\\r\\n        vec3<f32>(1.0, 0.0, 0.0),\\r\\n        vec3<f32>(0.0, 1.0, 0.0),\\r\\n        vec3<f32>(0.0, 0.0, 1.0),\\r\\n        vec3<f32>(1.0, 0.0, 0.0),\\r\\n        vec3<f32>(0.0, 1.0, 0.0),\\r\\n        vec3<f32>(0.0, 0.0, 1.0),  \\r\\n    );\\r\\n\\r\\n    var output: Output;\\r\\n    output.Position = vec4<f32>(pos[VertexIndex], 0.0, 1.0);\\r\\n    output.vColor = vec4<f32>(color[VertexIndex], 1.0);\\r\\n    return output;\\r\\n}\\r\\n\\r\\n// fragment shader\\r\\n\\r\\n@stage(fragment)\\r\\nfn fs_main(@location(0) vColor: vec4<f32>) -> @location(0) vec4<f32> {\\r\\n    return vColor;\\r\\n}\"","import { CheckWebGPU, InitGPU, CreateGPUBuffer } from \"./helper\";\r\nimport shader from './shader.wgsl'\r\nconst head = document.getElementById(\"id-gpu-check\");\r\nhead!.innerHTML=CheckWebGPU();\r\n\r\nconst CreatePrimitive = async (primitiveType = 'triangle-list') => {\r\n    const gpu = await InitGPU();\r\n    const device = gpu.device;\r\n    const format = gpu.format;\r\n\r\n    let indexFormat = undefined;\r\n    if(primitiveType === 'triangle-strip'){\r\n        indexFormat = 'uint32'\r\n    }\r\n    \r\n    let pipeline: GPURenderPipeline;\r\n    pipeline = device.createRenderPipeline({\r\n        vertex: {\r\n            module: device.createShaderModule({\r\n                code: shader\r\n            }),\r\n            entryPoint: \"vs_main\"\r\n        },\r\n        fragment: {\r\n            module: device.createShaderModule({\r\n                code: shader\r\n            }),\r\n            entryPoint: \"fs_main\",\r\n            targets: [{ format }]\r\n        },\r\n        primitive: {\r\n            topology: primitiveType as GPUPrimitiveTopology,\r\n            stripIndexFormat: indexFormat as GPUIndexFormat\r\n        },\r\n        layout: device.createPipelineLayout({bindGroupLayouts:[]}),\r\n    });\r\n    const commandEncoder = device.createCommandEncoder();\r\n    const textureView = gpu.context?.getCurrentTexture().createView() as GPUTextureView;\r\n    const renderPass = commandEncoder.beginRenderPass({\r\n        colorAttachments: [{\r\n            view:textureView,\r\n            clearValue:{r:0.2, g:0.4, b:0.2, a:1.0},\r\n            loadOp: 'clear',\r\n            storeOp:'store'\r\n        }]\r\n    });\r\n\r\n    renderPass.setPipeline(pipeline);\r\n    renderPass.draw(9);\r\n    renderPass.end();\r\n    device.queue.submit([commandEncoder.finish()]);\r\n}\r\n\r\nconst CreateSquare = async() => {\r\n    const gpu = await InitGPU();\r\n    const device: GPUDevice = gpu.device;\r\n\r\n    const vertexData = new Float32Array([\r\n        -0.5, -0.5,\r\n        0.5, -0.5,\r\n        -0.5, 0.5,\r\n        -0.5, 0.5,\r\n        0.5, -0.5,\r\n        0.5, 0.5\r\n    ])\r\n\r\n    const colorData = new Float32Array([\r\n        1,0,0,\r\n        0,1,0,\r\n        1,1,0,\r\n        1,1,0,\r\n        0,1,0,\r\n        0,0,1\r\n    ])\r\n\r\n    const vertexBuffer = CreateGPUBuffer(device,vertexData);\r\n    const colorBuffer = CreateGPUBuffer(device, colorData);\r\n\r\n    const pipeline = device.createRenderPipeline({\r\n        vertex: {\r\n            module: device.createShaderModule({\r\n                code:shader\r\n            }),\r\n            entryPoint: \"vs_main\",\r\n            buffers:[ \r\n                {\r\n                    arrayStride:8,\r\n                    attributes:[{\r\n                        shaderLocation:0,\r\n                        format: \"float32x2\",\r\n                        offset:0\r\n                    }]\r\n                },\r\n                {\r\n                    arrayStride:12,\r\n                    attributes:[{\r\n                        shaderLocation:1,\r\n                        format: \"float32x2\",\r\n                        offset:0\r\n                    }]\r\n                }]\r\n        },\r\n        fragment: {\r\n            module: device.createShaderModule({\r\n                code: shader,\r\n            }),\r\n            entryPoint: \"fs_main\",\r\n            targets: [\r\n                {\r\n                    format: gpu.format as GPUTextureFormat\r\n                }\r\n            ]\r\n        },\r\n        primitive:{\r\n            topology: \"triangle-list\"\r\n        },\r\n        layout: device.createPipelineLayout({bindGroupLayouts:[]})\r\n    })\r\n\r\n    const commandEncoder = device.createCommandEncoder();\r\n    const textureView = gpu.context.getCurrentTexture().createView();\r\n    const renderPass = commandEncoder.beginRenderPass({\r\n        colorAttachments: [{\r\n            view:textureView,\r\n            clearValue:{r:0.2, g:0.4, b:0.2, a:1.0},\r\n            loadOp: 'clear',\r\n            storeOp:'store'\r\n        }]\r\n    })\r\n\r\n    renderPass.setPipeline(pipeline);\r\n    renderPass.setVertexBuffer(0, vertexBuffer);\r\n    renderPass.setVertexBuffer(1, colorBuffer),\r\n    renderPass.draw(6);\r\n    renderPass.end();\r\n\r\n    device.queue.submit([commandEncoder.finish()]);\r\n}\r\n\r\nCreatePrimitive();\r\nlet primitiveSelector = document.getElementById(\"id-primitive\") as HTMLSelectElement;\r\nprimitiveSelector.addEventListener(\"change\", (e: any)=>{\r\n    CreatePrimitive(e.srcElement.value)\r\n})\r\n\r\n"],"names":["CheckWebGPU","result","navigator","gpu","document","getElementById","innerHTML","CreatePrimitive","primitiveType","includes","canvas","adapter","requestAdapter","device","requestDevice","context","getContext","format","window","devicePixelRatio","clientWidth","clientHeight","getPreferredCanvasFormat","configure","indexFormat","pipeline","createRenderPipeline","vertex","module","createShaderModule","code","entryPoint","fragment","targets","primitive","topology","stripIndexFormat","layout","createPipelineLayout","bindGroupLayouts","commandEncoder","createCommandEncoder","textureView","getCurrentTexture","createView","renderPass","beginRenderPass","colorAttachments","view","clearValue","r","g","b","a","loadOp","storeOp","setPipeline","draw","end","queue","submit","finish","addEventListener","e","srcElement","value"],"sourceRoot":""}